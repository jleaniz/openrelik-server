diff --git a/.coverage b/.coverage
new file mode 100644
index 0000000..a644b1a
Binary files /dev/null and b/.coverage differ
diff --git a/settings_example.toml b/settings_example.toml
index 2a0da26..0c7c860 100644
--- a/settings_example.toml
+++ b/settings_example.toml
@@ -39,6 +39,9 @@ jwt_header_default_access_expire_minutes = 5  # 5 minutes
 client_id = ""
 client_secret = ""
 
+# Extra client_ids for apps that authenticate with OpenRelik using Google OAuth.
+extra_audiences = []
+
 # Restrict logins from a Google Workspace domain.
 # Empty value = any domain, including gmail.com
 workspace_domain = ""
diff --git a/src/auth/google.py b/src/auth/google.py
index 3d4a253..646b593 100644
--- a/src/auth/google.py
+++ b/src/auth/google.py
@@ -11,6 +11,7 @@
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
+from typing import List, Any
 import uuid
 
 from authlib.integrations.starlette_client import OAuth, OAuthError
@@ -18,6 +19,8 @@ from fastapi import APIRouter, Depends, HTTPException
 from sqlalchemy.orm import Session
 from starlette.requests import Request
 from starlette.responses import RedirectResponse
+from google.auth.transport import requests
+from google.oauth2 import id_token
 
 from api.v1 import schemas
 from config import config
@@ -34,7 +37,7 @@ GOOGLE_CLIENT_SECRET = config["auth"]["google"]["client_secret"]
 GOOGLE_ALLOW_LIST = config["auth"]["google"]["allowlist"]
 GOOGLE_PUBLIC_ACCESS = config["auth"]["google"].get("public_access", False)
 GOOGLE_WORKSPACE_DOMAIN = config["auth"]["google"].get("workspace_domain", False)
-
+GOOGLE_EXTRA_AUDIENCES = config["auth"]["google"].get("extra_audiences", [])
 REFRESH_TOKEN_EXPIRE_MINUTES = config["auth"]["jwt_cookie_refresh_expire_minutes"]
 ACCESS_TOKEN_EXPIRE_MINUTES = config["auth"]["jwt_cookie_access_expire_minutes"]
 
@@ -47,6 +50,100 @@ oauth.register(
 )
 
 
+def _validate_google_token(token: str, expected_audiences: List[str]) -> dict[str, Any]:
+    """Validates a Google ID token.
+
+    Args:
+        token (str): The ID token to validate.
+        expected_audience (str): The expected audience for the token.
+
+    Raises:
+        HTTPException: If the token is invalid or the audience is not expected.
+    """
+    idinfo = id_token.verify_oauth2_token(token, requests.Request())
+    if idinfo["aud"] not in expected_audiences:
+        raise HTTPException(
+            status_code=401, detail="Unauthorized. Could not verify audience."
+        )
+    return idinfo
+
+
+def _validate_user_info(user_info: dict[str, Any]) -> None:
+    # Restrict logins to Google Workspace Domain if configured.
+    if GOOGLE_WORKSPACE_DOMAIN and user_info.get("hd") != GOOGLE_WORKSPACE_DOMAIN:
+        raise HTTPException(
+            status_code=401, detail="Unauthorized. Invalid workspace domain."
+        )
+
+    # Check if the user is allowed to login.
+    if GOOGLE_PUBLIC_ACCESS:
+        pass  # Let everyone in.
+    elif not user_info.get("email", "") in GOOGLE_ALLOW_LIST:
+        raise HTTPException(status_code=401, detail="Unauthorized. Not in allowlist.")
+
+
+@router.get("/auth/google/token")
+async def auth_header_token(request: Request, db: Session = Depends(get_db_connection)):
+    """Handles OpenRelik token generation for a user that provides a valid Google
+        authentication token. Used by API clients.
+
+    Args:
+        request (Request): The FastAPI request object.
+        db (Session): The database session object.
+
+    Returns:
+        dict: OpenRelik refresh and access tokens.
+    """
+    token = None
+    if "x-google-id-token" in request.headers:
+        token = request.headers["x-google-id-token"]
+    if not token:
+        raise HTTPException(
+            status_code=401, detail="Unauthorized, missing x-google-id-token header."
+        )
+
+    # Validate the JWT token's aud, exp and signature.
+    expected_audiences = [*GOOGLE_EXTRA_AUDIENCES, GOOGLE_CLIENT_ID]
+    user_info = _validate_google_token(token, expected_audiences)
+
+    # Validate the user is actually allowed based on OpenRelik coofig.
+    _validate_user_info(user_info)
+
+    user_email = user_info.get("email", "")
+    db_user = get_user_by_email_from_db(db, email=user_email)
+    if not db_user:
+        new_user = schemas.UserCreate(
+            display_name=user_info.get("name", ""),
+            username=user_email,
+            email=user_email,
+            auth_method="google",
+            profile_picture_url=user_info.get("picture", ""),
+            uuid=uuid.uuid4(),
+        )
+        db_user = create_user_in_db(db, new_user)
+
+    # Create JWT access token with default expiry time.
+    refresh_token = create_jwt_token(
+        audience="api-client",
+        expire_minutes=REFRESH_TOKEN_EXPIRE_MINUTES,
+        subject=db_user.uuid.hex,
+        token_type="refresh",
+    )
+
+    # Create JWT access token with default expiry time.
+    access_token = create_jwt_token(
+        audience="api-client",
+        expire_minutes=ACCESS_TOKEN_EXPIRE_MINUTES,
+        subject=db_user.uuid.hex,
+        token_type="access",
+    )
+
+    return {
+        "x-openrelik-refresh-token": refresh_token,
+        "x-openrelik-access-token": access_token,
+    }
+
+
 @router.get("/login/google")
 async def login(request: Request):
     """Redirects the user to the Google authentication endpoint.
@@ -93,15 +190,7 @@ async def auth(request: Request, db: Session = Depends(get_db_connection)):
     user_info = token.get("userinfo")
     user_email = user_info.get("email", "")
 
-    # Restrict logins to Google Workspace Domain if configured.
-    if GOOGLE_WORKSPACE_DOMAIN and user_info.get("hd") != GOOGLE_WORKSPACE_DOMAIN:
-        raise HTTPException(status_code=401, detail="Unauthorized")
-
-    # Check if the user is allowed to login.
-    if GOOGLE_PUBLIC_ACCESS:
-        pass  # Let everyone in.
-    elif not user_email in GOOGLE_ALLOW_LIST:
-        raise HTTPException(status_code=401, detail="Unauthorized")
+    _validate_user_info(user_info)
 
     db_user = get_user_by_email_from_db(db, email=user_email)
     if not db_user:
